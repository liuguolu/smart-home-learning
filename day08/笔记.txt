一：JPG库----》jpg或者jpeg图片-----》液晶
      jpg文件是有损的
	  jpg是24位颜色图
	JPEG格式：经过压缩-----》使用算法还原回RGB
    JPEG压缩算法：开源的第三库
	
	                  开源的第三方库
	经过压缩JPEG格式------------------》RGB------>lcd液晶屏幕
	
   1）下载飞秋的JPEG库：jpegsrc.v9a.tar.gz
   2) 把jpegsrc.v9a.tar.gz放置共享目录 
   3）在Ubuntu中，回到JPEG库所在的位置
       
	      cd  /mnt/hgfs/linux/jpegsrc.v9a.tar.gz
		  
   4)解压到家目录中
   
     tar zxvf  jpegsrc.v9a.tar.gz -C ~
	 
	 其中： 
	      tar：解压或者压缩的命令
		  z  ：解压以.gz结尾的压缩包  j----》.bz2
		  x  ：解压                   c----》压缩
		  v  ：可见的方式进行解压（把解压缩的过程打印出来）
		  f  ：文件
		  -C ：指定你解压的路径
		  ~  ：指定解压到位置
		  
   5）回到家目录下，看看是否解压成功
         回家目录  cd
                   ls-----》是否有jpeg-9a----》解压成功
   6）在家目录中创建一个新的目录，作为jpeg库安装
          回家目录 cd
		   mkdir   jpg
		   chmod  777 jpg
    7）切换到解压后目录
	   
	      cd  ~/jpeg-9a
		  
	8)配置
      ./configure  --host=arm-linux --prefix=/home/gec/jpg
 	
	9)编译
	   make
	
    10)安装
       make install

    11）检查是否安装成功
          cd ~/jpg
          ls		  
		  
		  bin：二进制文件
		  include：头文件
		 
		 jconfig.h  jerror.h  jmorecfg.h  jpeglib.
		  
		  lib：库文件
		   
		    libjpeg.so.9.1.0----》jpeg算法库
		
		  share：帮助文档
		  
	12)下载飞秋的jpeg_show.c文件
	       jpeg开放源码：jpeg_show.c
		   
	13)把jpeg_show.c放置到共享目录
	
	14)去Ubuntu中，回到jpeg_show.c所在路径下面
	   
	     cd  /mnt/hgfs/linux/
	
    15)编译工程
     arm-linux-gcc jpeg_show.c -o jpeg_show 
	 -I /home/gec/jpg/include -L /home/gec/jpg/lib/ -ljpeg
	
		arm-linux-gcc jpeg_show.c -o jpeg_show  编译命令
	    -I /home/gec/jpg/include ：指定头文件的路径
		-L /home/gec/jpg/lib/    ：指定库文件的路径
		-ljpeg	                 ：指定链接库jpeg
		
	
	16）把jpeg_show拷贝到开发板中
	    
		   rx 
	
	17）修改权限
            chmod 

    18）执行
         ./jpeg_show 1.jpg 	

	[root@GEC6818 /]#./jpeg_show 1.jpg 
   ./jpeg_show: error while loading shared libraries:
    libjpeg.so.9: cannot open shared object file:
	No such file or directory	  
		 解决方案：把libjpeg.so.9.1.0 下载到开发板
	
	19）先拷贝libjpeg.so.9.1.0到共享目录
	
	20）将库拷贝到CRT当中去；
		  
		  mv libjpeg.so.9.1.0 /lib
		  
		  并且将名字改为libjpeg.so.9
		  
	21）重新执行工程

===================摄像头=====================
1.在linux中那些常用的应用设备
  液晶显示屏幕、键盘、鼠标、触摸屏、摄像头、U盘等
  linux前辈设计很多的模型
       1.方便我们去调用驱动
	   2.按部就班的操作
	   
=============================================
2.由于这种原因我们在写的时候就可以按照模型的“套路”
   头文件指定库指定我们需要的路径
   宏定义包含了所有的状态
   函数主体
         1.打开文件（open 驱动）
		 2.代码功能模块
		 3.关闭文件
		 
=============================================
3.linux当中有关视频类的设备------》摄像头  统一的架构（V4l2）
  使程序有发现设备和操作设备的能力。
  它主要用一系列的函数实现我们想要的功能。
  像设置摄像头的参数、帧频、视频压缩格式和图像参数等。
  当然统一的架构只能在linux操作系统
      linux系统中有一个头文件和V4L2架构是相关的
	    vi /usr/include/linux/videodev2.h 
		
=============================================
4.帧捕捉画面
  帧――就是影像动画中最小单位的单幅影像画面，
  相当于电影胶片上的每一格镜头。 
  一帧就是一副静止的画面，连续的帧就形成动画
  
=============================================
5.摄像头操作流程：
    1.打开设备文件。 int fd=open("/dev/video7",O_RDWR);
	             注意(等开发板开启之后在插摄像touch)
	
	2. 取得设备的capability，看看设备具有什么功能，
	比如是否具有视频输入,或者音频输入输出等。VIDIOC_QUERYCAP,struct v4l2_capability（可选）
	
	3. 选择视频输入，一个视频设备可以有多个视频输入。VIDIOC_S_INPUT,struct v4l2_input
	
	4. 设置视频的制式和帧格式，制式包括PAL，NTSC，
	  帧的格式个包括宽度和高度等。
	VIDIOC_S_STD,VIDIOC_S_FMT,struct v4l2_std_id,struct v4l2_format
	
	5. 向驱动申请帧缓冲，一般不超过5个。
	    struct v4l2_requestbuffers
		
	6. 将申请到的帧缓冲映射到用户空间，
	   这样就可以直接操作采集到的帧了，而不必去复制。
	
	7. 将申请到的帧缓冲全部入队列，以便存放采集到的数据.
	    VIDIOC_QBUF,struct v4l2_buffer
		
	8. 开始视频的采集。VIDIOC_STREAMON
	   
	9. 出队列以取得已采集数据的帧缓冲，取得原始采集数据。
	   VIDIOC_DQBUF
	   
	10. 将缓冲重新入队列尾,这样可以循环采集。VIDIOC_QBUF
	     
	11. 停止视频的采集。VIDIOC_STREAMOFF
	
	12. 关闭视频设备。close(fd);

=======================================
摄像头：
    1.驱动/dev/video7
	2.使用结构体
	typedef struct Frame_Buffer
	{
		char buf[1843200]; //摄像头捕捉的数据显示（jpg：600*480）
		int length;        //摄像头捕捉的数据大小	
	}FrameBuffer;

    3.代码功能模块
	 //初始化摄像头
	 int linux_v4l2_device_init(const char *dev);

	 //开启摄像头捕捉
	 int linux_v4l2_start_capturing();

     //获取摄像头的画面
	 int linux_v4l2_get_fream(FrameBuffer *freambuf);

     //摄像头显示画面
	 int show_video_data(unsigned int x,unsigned int y,
	  	  char *pjpg_buf,unsigned int jpg_buf_size)  
      
	 //摄像头暂停捕捉
	  int linux_v4l2_stop_capturing();

	 //解除摄像头的初始化 
     int linux_v4l2_device_uinit();
	
====================================
头文件：
      什么时候用<.h>  头文件存在系统库里面
	  什么时候用".h"  头文件不在系统库，根据当前目录查找
	  
编译命令
   arm-linux-gcc *.c -o viode_show -L./jpeg -lapi_v4l2_arm -I./jpeg -ljpeg














		  
	 
	 
   
   